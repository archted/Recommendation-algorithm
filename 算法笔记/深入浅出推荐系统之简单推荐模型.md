# 深入浅出推荐系统之简单推荐模型

下面我们开始介绍最简单的推荐系统：基于流行度的推荐模型。

## 流行度模型

推荐系统中最基本的推荐模型：**基于流行度的推荐模型**，通俗讲就是什么内容吸引用户就推荐用户什么内容。

这边一个衡量内容的标准是**流行度**，影响物品流行度的因素有很多：时间因素、空间因素、社会心理因素、个性 VS 群体。

因此，我们在衡量流行度上就不能使用**绝对值，而应该使用的是一个“比值”（Ratio），或者是计算某种“可能性”（Probability）**。

一个可行的方式就是计算点击率。如果从数学上对点击率建模，其实可以把一个物品在显示之后是否被点击看成是一个“**伯努利随机变量**”，于是对点击率的估计，就变成了对一个伯努利分布参数估计的过程。

另外一种解决方案是基于不同的时间段来预估点击率，我们可以使用上一时间段的点击率作为先验知识来更加准确地估计现在这个时段的点击率。

## 基于内容特征的推荐模型

•依赖性低，不需要动态的用户行为，只要有内容就可以进行推荐

•系统不同阶段都可以应用,可以解决冷启动问题

步骤：

1.物品表示 Item Representation：

为每个item抽取出features

2.用户的喜好特征学习Profile Learning：

利用一个用户过去喜欢（不喜欢）的item的特征数据，来学习该用户的喜好特征（profile）；

3.生成推荐列表Recommendation Generation：

通过用户profile与候选item的特征，推荐相关性最大的item。

## 相似度模型(协同过滤)

介绍完基于流行度的推荐模型后，我们接着看**基于相似信息的推荐模型**，这类模型又叫做**协同过滤**，其总结起来就是：

> 相似的用户可能会有相似的喜好，相似的物品可能会被相似的人所偏好。

于是我们就要去寻找相似的用户或者相似的物品。

协同过滤的核心思想是**聚类**。比如寻找相似的用户的方法是我们把用户 A 和用户 B**“聚类”**到了一起，认为他们代表了一个类型的用户。我们把对单个用户的建模抽象到了某个类型的用户，从而能够获得更多的数据。寻找相似的物品也是同样的方法。

协同主要有两类：

- 基于记忆的协同（基于邻域的推荐）
  - 用户协同
  - 物品协同
- 基于模型的协同

**基于记忆的协同，其重点在于记忆，记住每个人消费过的物品，然后给他推荐**，此时又可细分为

- 用户协同：跟你相似的人都消费过什么
- 物品协同：跟你消费过物品相似的物品有哪些

因此基于记忆的协同，重点就在于去找相似的用户或者相似的物品，我们先来看相似的用户。

### 用户协同

用户协同背后的思想是：根据用户的历史行为，**对用户进行聚类**，然后**基于同一类用户的共同喜好**，给用户推荐物品。

用户协同的核心公式：

<font face="黑体"  size=6>$P_{u,i}=\frac{\sum_{v=1}^n (sim_{u,v}*R_{v,i})}{\sum_{v=1}^n sim_{u,v}}$</font>

我们来解读下上面的公式：
公式左边的<font face="黑体"  size=5>$P_{u,i}$</font>表示用户u对物品i的预测，公式右边是一个关于用户u和用户j的一个相似度加权，<font face="黑体"  size=5>$sim_{u,v}$</font>表示用户u和用户v的相似度，<font face="黑体"  size=5>$R_{v,i}$</font>表示用户v对物品i的评分。

其中相似度的计算有三种方式：1）Jaccard相似度；2）余弦相似度；3）基于流行度改进的相似度计算。

有了上面的公式后，我们就来看实际生产中要运用的话，需要注意的几个地方：

1. 因为要计算任意两个用户的相似度，所有复杂度为$O(n^2)$
3. 要计算每个用户和物品之间的相互关系，复杂度是$O(mn)$

针对上面的问题，可以看我github上的[代码](https://github.com/zhuanxuhit/kaggle/blob/master/tencentAd/2-协同过滤版本.ipynb)是如何解决的，欢迎大家star。

### 物品协同

物品协同的关键公式如下：

<font face="黑体"  size=6>$\hat{P}_{u,i}=\frac{\sum_{j=1}^m (sim_{i,j}*R_{u,j})}{\sum_{j=1}^m sim_{i,j}}$</font>

有了前面用户协同的基础后，可以很容易的看懂。此处我们需要记住的关键点是：

- 用户的喜好相比于物品的特征变化快

总结来说：物品协同就是根据用户已有记录的物品，去找跟这些物品最相似的物品。

#### slope one 算法

**slope one 算法是面对物品协同中模型无法在线更新的问题而提出的。由 Daniel Lemire在 2005 年提出的一个Item-Based 的协同过滤推荐算法。**

其主要创新点在于引入了：

1. 通过引入两个物品的共同用户数量来代表两个物品差距的置信程度
2. 模型可以在线实时更新

举例：

|      | **a** | **b** | **c** | **d** |
| ---- | ----- | ----- | ----- | ----- |
| A    | 5     | 3.5   |       |       |
| B    | 2     | 5     | 4     | 2     |
| C    | 4.5   | 3.5   | 1     | 4     |

Step1，计算Item之间的评分差的均值

b与a：((3.5-5)+(5-2)+(3.5-4.5))/3=0.5/3

c与a：((4-2)+(1-4.5))/2=-1.5/2

d与a：((2-2)+(4-4.5))/2=-0.5/2

c与b：((4-5)+(1-3.5))/2=-3.5/2

d与b：((2-5)+(4-3.5))/2=-2.5/2

d与c：((2-4)+(4-1))/2=1/2

Step2，预测用户A对商品c和d的评分

a对c评分=((-0.75+5)+(-1.75+3.5))/2=3

a对d评分=((-0.25+5)+(-1.25+3.5))/2=3.5

Step3，将预测评分排序，推荐给用户

推荐顺序为{d, c}

### 



## 总结

本文介绍了三种推荐模型：

- 基于流行度的推荐模型
- 基于内容特征的推荐模型
- 基于相似信息的推荐模型

其中基于流行度的模型简单有效，可以通过一些先验知识，解决部分冷启动问题；

基于内容特征的推荐模型不依赖用户动态行为，从用户的profile中选择与候选item相似性最大的物品进行推荐；

而基于相似信息的推荐模型则是充分利用群体智慧，通过聚类的方式来解决用户、物品稀疏的问题。